### GC是什么

* 次数上频繁收集`Young区`
* 次数上较少收集`Old区`
* 基本不动`元空间`

**Minor GC**

* 指发生`在新生代`的垃`圾收集动作`, 大多数Java对象存活率都不高, 所以`MinorGC`非常频繁, **一般回收速度也比较快**

**Major GC**

* 指发生在`老年代`的`垃圾收集动作`, 出现`MajorGC`通常伴随着`至少一次``MinorGC`(**但也不是绝对的**)。`MajorGC`的速度一般要比`MinorGC``慢``10倍`以上。



### 引用计数法

* 每次对对象赋值时都要维护引用计数器, 且引用计数器本身也有一定的消耗
* 没办法处理循环引用

**JVM的实现一般不采用这种方式**



### 标记清除(Mark-Sweep)

* 算法分为标记和清除两个阶段, 先标记出要回收的对象, 然后统一回收这些对象
* 优点
  * 节约空间
* 缺点
  * 效率问题, 标记和清除效率都不高
  * 标记清除后产生大量不连续的内存碎片, 可能导致在以后分配大的对象时, 无法找到足够的空间而不得不提前触发一次垃圾收集动作



### 复制算法(Copying)

在`GC`开始的时候, 对象只会存在`Eden`区和名为`From`的`Survivor`区, `Survivor`区`To`是空的, 紧接着进行`GC`, `Eden`区中所有存活的对象都会被复制到`To`, 而在`Form`区中, 仍然存活的对象会根据他们的年龄值来决定去向。**年龄达到一定值(年龄阈值, 可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到老年代中, 没有达到阈值的则会被复制到To区域**。经过这次GC后, **Eden区与From区都已经被清空, 这个时候From与To会交换他们的角色, 也就是说新的To就是GC之前的From, 新的From就是GC之前的To**。不管怎样, 都会保证名为`To`的`Survivor`区域是空的, `MinorGC`会一直重复这样的过程。

**主要用于新生代**

* 优点
  * 直接复制存活的对象到另一块`Survivor`上, 然后把使用过的空间一次性清理掉, 实现简单运行高效
  * 不会产生内存碎片
* 缺点
  * 浪费一半内存
  * 在对象存活率高时, 复制对象花费的时间将变得不能忽视, 复制算法适用于存活率非常低的情况



### 标记压缩(Mark-Compact)

标记过程与`标记-清除`算法一样, 但是后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉端边界以外的内存

* 优点
  * 不浪费一半空间
  * 不会产生内存碎片
* 缺点
  * 耗时长, 效率不高



**老年代一般是由标记清除或者是标记清除与标记压缩的混合实现**



### GC Roots

* 虚拟机栈(栈帧中的本地变量表)中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI(即一般所说的Native方法)引用的对象



### [Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036)

